package geometry

import (
	"errors"
	"math"
)

type Point struct {
	X int32
	Y int32
}

type Segment struct {
	P1 Point
	P2 Point
}

func Intersection(segment1, segment2 Segment) (Point, error) {
	x1 := float64(segment1.P1.X)
	y1 := float64(segment1.P1.Y)
	x2 := float64(segment1.P2.X)
	y2 := float64(segment1.P2.Y)

	x3 := float64(segment2.P1.X)
	y3 := float64(segment2.P1.Y)
	x4 := float64(segment2.P2.X)
	y4 := float64(segment2.P2.Y)

	t := ((x1-x3)*(y3-y4) - (y1-y3)*(x3-x4)) / ((x1-x2)*(y3-y4) - (y1-y2)*(x3-x4))

	u := -((x1-x2)*(y1-y3) - (y1-y2)*(x1-x3)) / ((x1-x2)*(y3-y4) - (y1-y2)*(x3-x4))

	if math.IsNaN(t) || math.IsNaN(u) {
		//the segments are parallel
		if x1 == x2 && x2 == x3 {
			//the segments are parallel to the y axis
			if math.Min(y1, y2) <= y3 && y3 <= math.Max(y1, y2) {
				return segment2.P1, nil
			}
			if math.Min(y1, y2) <= y4 && y4 <= math.Max(y1, y2) {
				return segment2.P2, nil
			}
		}
		m1 := (y1 - y2) / (x1 - x2)
		q1 := y1 - (m1 * x1)
		m2 := (y3 - y4) / (x3 - x4)
		q2 := y3 - (m2 * x3)
		if q1 == q2 {
			if math.Min(x1, x2) <= x3 && x3 <= math.Max(x1, x2) {
				return segment2.P1, nil
			}
			if math.Min(x1, x2) <= x4 && x4 <= math.Max(x1, x2) {
				return segment2.P2, nil
			}
		}
		return Point{}, errors.New("the lines generated by the segments are parallel but not intersecting")
	}

	if t < 0 || t > 1 || u < 0 || u > 1 {
		return Point{}, errors.New("the lines generated by the segments are not intersecting")
	}
	intersection := Point{int32(x1 + t*(x2-x1)), int32(y1 + t*(y2-y1))}
	return intersection, nil
}
