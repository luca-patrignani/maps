package geometry

import (
	"errors"
	"math"
)

type Segment struct {
	P1 Point
	P2 Point
}

func Intersection(segment1, segment2 Segment) (Point, error) {
	x1 := segment1.P1.X
	y1 := segment1.P1.Y
	x2 := segment1.P2.X
	y2 := segment1.P2.Y
	x3 := segment2.P1.X
	y3 := segment2.P1.Y
	x4 := segment2.P2.X
	y4 := segment2.P2.Y

	t := ((x1-x3)*(y3-y4) - (y1-y3)*(x3-x4)) / ((x1-x2)*(y3-y4) - (y1-y2)*(x3-x4))

	u := -((x1-x2)*(y1-y3) - (y1-y2)*(x1-x3)) / ((x1-x2)*(y3-y4) - (y1-y2)*(x3-x4))

	if math.IsNaN(t) || math.IsNaN(u) {
		//the segments are parallel
		if x1 == x2 && x3 == x4 {
			//the segments are parallel to the y axis
			if math.Min(y1, y2) <= y3 && y3 <= math.Max(y1, y2) {
				return segment2.P1, nil
			}
			if math.Min(y1, y2) <= y4 && y4 <= math.Max(y1, y2) {
				return segment2.P2, nil
			}
			return Point{}, errors.New("the lines generated by the segments are parallel but not intersecting")
		}
		m1 := (y1 - y2) / (x1 - x2)
		q1 := y1 - (m1 * x1)
		m2 := (y3 - y4) / (x3 - x4)
		q2 := y3 - (m2 * x3)
		if q1 == q2 {
			if math.Min(x3, x4) <= x1 && x1 <= math.Max(x3, x4) {
				return segment1.P1, nil
			}
			if math.Min(x3, x4) <= x2 && x2 <= math.Max(x3, x4) {
				return segment1.P2, nil
			}
			if math.Min(x1, x2) <= x3 && x3 <= math.Max(x1, x2) {
				return segment2.P1, nil
			}
			if math.Min(x1, x2) <= x4 && x4 <= math.Max(x1, x2) {
				return segment2.P2, nil
			}
		}
		return Point{}, errors.New("the lines generated by the segments are parallel but not intersecting")
	}

	if t < 0 || t > 1 || u < 0 || u > 1 {
		return Point{}, errors.New("the lines generated by the segments are not intersecting")
	}
	intersection := Point{x1 + t*(x2-x1), y1 + t*(y2-y1)}
	return intersection, nil
}

func (segment1 Segment) IsParallelTo(segment2 Segment) bool {
	x1 := float64(segment1.P1.X)
	y1 := float64(segment1.P1.Y)
	x2 := float64(segment1.P2.X)
	y2 := float64(segment1.P2.Y)

	x3 := float64(segment2.P1.X)
	y3 := float64(segment2.P1.Y)
	x4 := float64(segment2.P2.X)
	y4 := float64(segment2.P2.Y)
	return (x1-x2)*(y3-y4)-(y1-y2)*(x3-x4) == 0
}

func (s Segment) Length() float64 {
	return s.P1.Distance(s.P2)
}

func (s Segment) Contains(p Point) bool {
	if s.P1.X == s.P2.X {
		return s.P1.X == p.X && math.Min(s.P1.Y, s.P2.Y) <= p.Y && p.Y <= math.Max(s.P1.Y, s.P2.Y)
	}
	m := (s.P1.Y - s.P2.Y) / (s.P1.X - s.P2.X)
	q := s.P1.Y - (m * s.P1.X)
	return p.X*m+q == p.Y && math.Min(s.P1.X, s.P2.X) <= p.X && p.X <= math.Max(s.P1.X, s.P2.X)
}
